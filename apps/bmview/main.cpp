/*  Simple image viewer for AtheOS
 *  Copyright (C) 2001 Kurt Skauen
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
 *  MA 02111-1307, USA
 */

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <atheos/time.h>
#include <gui/window.h>
#include <gui/bitmap.h>
#include <util/application.h>

#include <storage/file.h>
#include <translation/translator.h>

#define min( a, b ) (((a) < (b)) ? (a) : (b))

using namespace os;

class MyWindow : public Window
{
public:
  MyWindow( const Rect& cFrame, const char* pzName, const char* pzTitle );
  virtual bool OkToQuit();
};

MyWindow::MyWindow( const Rect& cFrame, const char* pzName, const char* pzTitle ) : Window( cFrame, pzName, pzTitle )
{
}

bool MyWindow::OkToQuit( void )
{
  Application::GetInstance()->PostMessage( M_QUIT );
  return( true );
}

struct PalletteEntry_s
{
  uint8 nRed;
  uint8	nGreen;
  uint8	nBlue;
  uint8	nAlpha;
};

PalletteEntry_s asDefaultPallette[] = {
  {0x00, 0x00, 0x00, 0x00},
  {0x08, 0x08, 0x08, 0x00},
  {0x10, 0x10, 0x10, 0x00},
  {0x18, 0x18, 0x18, 0x00},
  {0x20, 0x20, 0x20, 0x00},
  {0x28, 0x28, 0x28, 0x00},
  {0x30, 0x30, 0x30, 0x00},
  {0x38, 0x38, 0x38, 0x00},
  {0x40, 0x40, 0x40, 0x00},
  {0x48, 0x48, 0x48, 0x00},
  {0x50, 0x50, 0x50, 0x00},
  {0x58, 0x58, 0x58, 0x00},
  {0x60, 0x60, 0x60, 0x00},
  {0x68, 0x68, 0x68, 0x00},
  {0x70, 0x70, 0x70, 0x00},
  {0x78, 0x78, 0x78, 0x00},
  {0x80, 0x80, 0x80, 0x00},
  {0x88, 0x88, 0x88, 0x00},
  {0x90, 0x90, 0x90, 0x00},
  {0x98, 0x98, 0x98, 0x00},
  {0xa0, 0xa0, 0xa0, 0x00},
  {0xa8, 0xa8, 0xa8, 0x00},
  {0xb0, 0xb0, 0xb0, 0x00},
  {0xb8, 0xb8, 0xb8, 0x00},
  {0xc0, 0xc0, 0xc0, 0x00},
  {0xc8, 0xc8, 0xc8, 0x00},
  {0xd0, 0xd0, 0xd0, 0x00},
  {0xd9, 0xd9, 0xd9, 0x00},
  {0xe2, 0xe2, 0xe2, 0x00},
  {0xeb, 0xeb, 0xeb, 0x00},
  {0xf5, 0xf5, 0xf5, 0x00},
  {0xfe, 0xfe, 0xfe, 0x00},
  {0xff, 0x00, 0x00, 0x00},
  {0xe5, 0x00, 0x00, 0x00},
  {0xcc, 0x00, 0x00, 0x00},
  {0xb3, 0x00, 0x00, 0x00},
  {0x9a, 0x00, 0x00, 0x00},
  {0x81, 0x00, 0x00, 0x00},
  {0x69, 0x00, 0x00, 0x00},
  {0x50, 0x00, 0x00, 0x00},
  {0x37, 0x00, 0x00, 0x00},
  {0x1e, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0xff, 0x00},
  {0x00, 0x00, 0xe4, 0x00},
  {0x00, 0x00, 0xcb, 0x00},
  {0x00, 0x00, 0xb2, 0x00},
  {0x00, 0x00, 0x99, 0x00},
  {0x00, 0x00, 0x80, 0x00},
  {0x00, 0x00, 0x69, 0x00},
  {0x00, 0x00, 0x50, 0x00},
  {0x00, 0x00, 0x37, 0x00},
  {0x00, 0x00, 0x1e, 0x00},
  {0x00, 0xff, 0x00, 0x00},
  {0x00, 0xe4, 0x00, 0x00},
  {0x00, 0xcb, 0x00, 0x00},
  {0x00, 0xb2, 0x00, 0x00},
  {0x00, 0x99, 0x00, 0x00},
  {0x00, 0x80, 0x00, 0x00},
  {0x00, 0x69, 0x00, 0x00},
  {0x00, 0x50, 0x00, 0x00},
  {0x00, 0x37, 0x00, 0x00},
  {0x00, 0x1e, 0x00, 0x00},
  {0x33, 0x98, 0x00, 0x00},
  {0xff, 0xff, 0xff, 0x00},
  {0xff, 0xff, 0xcb, 0x00},
  {0xcb, 0xff, 0xcb, 0x00},
  {0x98, 0xff, 0xcb, 0x00},
  {0x66, 0xff, 0xcb, 0x00},
  {0x33, 0xff, 0xcb, 0x00},
  {0x00, 0xff, 0xcb, 0x00},
  {0xff, 0xff, 0x98, 0x00},
  {0xcb, 0xff, 0x98, 0x00},
  {0x98, 0xff, 0x98, 0x00},
  {0x66, 0xff, 0x98, 0x00},
  {0x33, 0xff, 0x98, 0x00},
  {0x00, 0xff, 0x98, 0x00},
  {0xff, 0xff, 0x66, 0x00},
  {0xcb, 0xff, 0x66, 0x00},
  {0x98, 0xff, 0x66, 0x00},
  {0x66, 0xff, 0x66, 0x00},
  {0x33, 0xff, 0x66, 0x00},
  {0x00, 0xff, 0x66, 0x00},
  {0xff, 0xff, 0x33, 0x00},
  {0xcb, 0xff, 0x33, 0x00},
  {0x98, 0xff, 0x33, 0x00},
  {0x66, 0xff, 0x33, 0x00},
  {0x33, 0xff, 0x33, 0x00},
  {0x00, 0xff, 0x33, 0x00},
  {0xff, 0x98, 0xff, 0x00},
  {0xcb, 0x98, 0xff, 0x00},
  {0x98, 0x98, 0xff, 0x00},
  {0x66, 0x98, 0xff, 0x00},
  {0x33, 0x98, 0xff, 0x00},
  {0x00, 0x98, 0xff, 0x00},
  {0xff, 0x66, 0x00, 0x00},
  {0xcb, 0x66, 0x00, 0x00},
  {0xff, 0xcb, 0xcb, 0x00},
  {0xcb, 0xcb, 0xcb, 0x00},
  {0x98, 0xcb, 0xcb, 0x00},
  {0x66, 0xcb, 0xcb, 0x00},
  {0x33, 0xcb, 0xcb, 0x00},
  {0x00, 0xcb, 0xcb, 0x00},
  {0xff, 0xcb, 0x98, 0x00},
  {0xcb, 0xcb, 0x98, 0x00},
  {0x98, 0xcb, 0x98, 0x00},
  {0x66, 0xcb, 0x98, 0x00},
  {0x33, 0xcb, 0x98, 0x00},
  {0x00, 0xcb, 0x98, 0x00},
  {0xff, 0xcb, 0x66, 0x00},
  {0xcb, 0xcb, 0x66, 0x00},
  {0x98, 0xcb, 0x66, 0x00},
  {0x66, 0xcb, 0x66, 0x00},
  {0x33, 0xcb, 0x66, 0x00},
  {0x00, 0xcb, 0x66, 0x00},
  {0xff, 0xcb, 0x33, 0x00},
  {0xcb, 0xcb, 0x33, 0x00},
  {0x98, 0xcb, 0x33, 0x00},
  {0x66, 0xcb, 0x33, 0x00},
  {0x33, 0xcb, 0x33, 0x00},
  {0x00, 0xcb, 0x33, 0x00},
  {0xff, 0x66, 0xff, 0x00},
  {0xcb, 0x66, 0xff, 0x00},
  {0x98, 0x66, 0xff, 0x00},
  {0x66, 0x66, 0xff, 0x00},
  {0x33, 0x66, 0xff, 0x00},
  {0x00, 0x66, 0xff, 0x00},
  {0x98, 0x66, 0x00, 0x00},
  {0x66, 0x66, 0x00, 0x00},
  {0xff, 0x98, 0xcb, 0x00},
  {0xcb, 0x98, 0xcb, 0x00},
  {0x98, 0x98, 0xcb, 0x00},
  {0x66, 0x98, 0xcb, 0x00},
  {0x33, 0x98, 0xcb, 0x00},
  {0x00, 0x98, 0xcb, 0x00},
  {0xff, 0x98, 0x98, 0x00},
  {0xcb, 0x98, 0x98, 0x00},
  {0x98, 0x98, 0x98, 0x00},
  {0x66, 0x98, 0x98, 0x00},
  {0x33, 0x98, 0x98, 0x00},
  {0x00, 0x98, 0x98, 0x00},
  {0xff, 0x98, 0x66, 0x00},
  {0xcb, 0x98, 0x66, 0x00},
  {0x98, 0x98, 0x66, 0x00},
  {0x66, 0x98, 0x66, 0x00},
  {0x33, 0x98, 0x66, 0x00},
  {0x00, 0x98, 0x66, 0x00},
  {0xff, 0x98, 0x33, 0x00},
  {0xcb, 0x98, 0x33, 0x00},
  {0x98, 0x98, 0x33, 0x00},
  {0x66, 0x98, 0x33, 0x00},
  {0x33, 0x98, 0x33, 0x00},
  {0x00, 0x98, 0x33, 0x00},
  {0x00, 0x86, 0xe6, 0x00},
  {0xcb, 0x33, 0xff, 0x00},
  {0x98, 0x33, 0xff, 0x00},
  {0x66, 0x33, 0xff, 0x00},
  {0x33, 0x33, 0xff, 0x00},
  {0x00, 0x33, 0xff, 0x00},
  {0x33, 0x66, 0x00, 0x00},
  {0x00, 0x66, 0x00, 0x00},
  {0xff, 0x66, 0xcb, 0x00},
  {0xcb, 0x66, 0xcb, 0x00},
  {0x98, 0x66, 0xcb, 0x00},
  {0x66, 0x66, 0xcb, 0x00},
  {0x33, 0x66, 0xcb, 0x00},
  {0x00, 0x66, 0xcb, 0x00},
  {0xff, 0x66, 0x98, 0x00},
  {0xcb, 0x66, 0x98, 0x00},
  {0x98, 0x66, 0x98, 0x00},
  {0x66, 0x66, 0x98, 0x00},
  {0x33, 0x66, 0x98, 0x00},
  {0x00, 0x66, 0x98, 0x00},
  {0xff, 0x66, 0x66, 0x00},
  {0xcb, 0x66, 0x66, 0x00},
  {0x98, 0x66, 0x66, 0x00},
  {0x66, 0x66, 0x66, 0x00},
  {0x33, 0x66, 0x66, 0x00},
  {0x00, 0x66, 0x66, 0x00},
  {0xff, 0x66, 0x33, 0x00},
  {0xcb, 0x66, 0x33, 0x00},
  {0x98, 0x66, 0x33, 0x00},
  {0x66, 0x66, 0x33, 0x00},
  {0x33, 0x66, 0x33, 0x00},
  {0x00, 0x66, 0x33, 0x00},
  {0xff, 0x00, 0xff, 0x00},
  {0xcb, 0x00, 0xff, 0x00},
  {0x98, 0x00, 0xff, 0x00},
  {0x66, 0x00, 0xff, 0x00},
  {0x33, 0x00, 0xff, 0x00},
  {0x13, 0xaf, 0xff, 0x00},
  {0xff, 0x33, 0x00, 0x00},
  {0xcb, 0x33, 0x00, 0x00},
  {0xff, 0x33, 0xcb, 0x00},
  {0xcb, 0x33, 0xcb, 0x00},
  {0x98, 0x33, 0xcb, 0x00},
  {0x66, 0x33, 0xcb, 0x00},
  {0x33, 0x33, 0xcb, 0x00},
  {0x00, 0x33, 0xcb, 0x00},
  {0xff, 0x33, 0x98, 0x00},
  {0xcb, 0x33, 0x98, 0x00},
  {0x98, 0x33, 0x98, 0x00},
  {0x66, 0x33, 0x98, 0x00},
  {0x33, 0x33, 0x98, 0x00},
  {0x00, 0x33, 0x98, 0x00},
  {0xff, 0x33, 0x66, 0x00},
  {0xcb, 0x33, 0x66, 0x00},
  {0x98, 0x33, 0x66, 0x00},
  {0x66, 0x33, 0x66, 0x00},
  {0x33, 0x33, 0x66, 0x00},
  {0x00, 0x33, 0x66, 0x00},
  {0xff, 0x33, 0x33, 0x00},
  {0xcb, 0x33, 0x33, 0x00},
  {0x98, 0x33, 0x33, 0x00},
  {0x66, 0x33, 0x33, 0x00},
  {0x33, 0x33, 0x33, 0x00},
  {0x00, 0x33, 0x33, 0x00},
  {0x66, 0xcb, 0xff, 0x00},
  {0x98, 0xcb, 0xff, 0x00},
  {0xcb, 0xcb, 0xff, 0x00},
  {0xff, 0xcb, 0xff, 0x00},
  {0x98, 0x33, 0x00, 0x00},
  {0x66, 0x33, 0x00, 0x00},
  {0x33, 0x33, 0x00, 0x00},
  {0x00, 0x33, 0x00, 0x00},
  {0xff, 0x00, 0xcb, 0x00},
  {0xcb, 0x00, 0xcb, 0x00},
  {0x98, 0x00, 0xcb, 0x00},
  {0x66, 0x00, 0xcb, 0x00},
  {0x33, 0x00, 0xcb, 0x00},
  {0x46, 0xe3, 0xff, 0x00},
  {0xff, 0x00, 0x98, 0x00},
  {0xcb, 0x00, 0x98, 0x00},
  {0x98, 0x00, 0x98, 0x00},
  {0x66, 0x00, 0x98, 0x00},
  {0x33, 0x00, 0x98, 0x00},
  {0x00, 0x00, 0x98, 0x00},
  {0xff, 0x00, 0x66, 0x00},
  {0xcb, 0x00, 0x66, 0x00},
  {0x98, 0x00, 0x66, 0x00},
  {0x66, 0x00, 0x66, 0x00},
  {0x33, 0x00, 0x66, 0x00},
  {0x00, 0x00, 0x66, 0x00},
  {0xff, 0x00, 0x33, 0x00},
  {0xcb, 0x00, 0x33, 0x00},
  {0x98, 0x00, 0x33, 0x00},
  {0x66, 0x00, 0x33, 0x00},
  {0x33, 0x00, 0x33, 0x00},
  {0x00, 0x00, 0x33, 0x00},
  {0x33, 0xcb, 0xff, 0x00},
  {0x00, 0xcb, 0xff, 0x00},
  {0x00, 0xff, 0xff, 0x00},
  {0x33, 0xff, 0xff, 0x00},
  {0x66, 0xff, 0xff, 0x00},
  {0x98, 0xff, 0xff, 0x00},
  {0xcb, 0xff, 0xff, 0x00},
  {0xff, 0xff, 0xff, 0xff}
};

struct BitmapFileHeader_s
{
  uint16	nType;
  uint32	nSize;
  uint16	nReserved1;
  uint16	nReserved2;
  uint32	nRasterOffset;
} __attribute__((packed));

struct BitmapInfoHeader_s
{
  uint32	nSize;
  uint32	nWidth;
  uint32	nHeight;;
  uint16	nPlanes;
  uint16	nBitsPerPix;
  uint32	nCompression;
  uint32	nImageSize;
  int32		nPelsPerMeterX;
  int32		nPelsPerMeterY;
  uint32	nColorsUsed;
  uint32	nImportantColors;
};

Bitmap* LoadBmp( const char* pzPath )
{
  BitmapFileHeader_s sFileHeader;
  BitmapInfoHeader_s sBitmapHeader;
  
  FILE* hFile = fopen( pzPath, "r" );

  if ( hFile == NULL ) {
    printf( "Failed to open %s\n", pzPath );
    return( NULL );
  }
  fread( &sFileHeader, 1, sizeof( sFileHeader ), hFile );
  printf( "Type = %d\n", sFileHeader.nType );
  printf( "Size = %ld\n", sFileHeader.nSize );
  printf( "Offs = %ld\n", sFileHeader.nRasterOffset );
  fread( &sBitmapHeader, 1, sizeof( sBitmapHeader ), hFile );
  printf( "Width  = %ld\n", sBitmapHeader.nWidth );
  printf( "Height = %ld\n", sBitmapHeader.nHeight );
  printf( "Planes = %d\n", sBitmapHeader.nPlanes );
  printf( "Depth  = %d\n", sBitmapHeader.nBitsPerPix );

  dbprintf( "Create bitmap\n" );
  Bitmap* pcBitmap = new Bitmap( sBitmapHeader.nWidth, sBitmapHeader.nHeight, CS_RGB32,
				 Bitmap::SHARE_FRAMEBUFFER | Bitmap::ACCEPT_VIEWS );
  dbprintf( "Get raster\n" );
  uint8* pRaster = pcBitmap->LockRaster();
  
  if ( sBitmapHeader.nBitsPerPix <= 8 )
  {
    int nPalSize = 1 << sBitmapHeader.nBitsPerPix;
    int nLineSize   = (sBitmapHeader.nWidth * sBitmapHeader.nBitsPerPix / 8 + 1) & ~1;
    int nRasterSize = sBitmapHeader.nHeight * nLineSize;

    Color32_s* pasPallette = new Color32_s[ nPalSize ];
    uint8*     pBuffer = new uint8[ nRasterSize ];
    uint8*     pSrc = pBuffer + nRasterSize - nLineSize;
    
    fread( pasPallette, nPalSize, sizeof( Color32_s ), hFile );
/*
    for ( int i = 0 ; i < nPalSize ; ++i ) {
      printf( "  {{0x%02x, 0x%02x, 0x%02x, 0x%02x}},\n", pasPallette[i].anRGBA[0], pasPallette[i].anRGBA[1], pasPallette[i].anRGBA[2], pasPallette[i].anRGBA[3] );
    }
    exit(0);
    */    
    fseek( hFile, /*sizeof( sFileHeader ) +*/ sFileHeader.nRasterOffset, SEEK_SET );
    fread( pBuffer, nRasterSize, 1, hFile );
    
    if ( sBitmapHeader.nBitsPerPix == 8 ) {
      for ( uint y = 0 ; y < sBitmapHeader.nHeight ; ++y )
      {
	for ( uint x = 0 ; x < sBitmapHeader.nWidth ; ++x )
	{
	  int nPix = *pSrc++;
	  
	  *pRaster++ = pasPallette[ nPix ].red;
	  *pRaster++ = pasPallette[ nPix ].green;
	  *pRaster++ = pasPallette[ nPix ].blue;
	  *pRaster++ = 0;
	}
	if ( sBitmapHeader.nWidth & 0x01 ) {
	  pSrc++;
	}
	pSrc -= nLineSize * 2;
      }
    } else if ( sBitmapHeader.nBitsPerPix == 4 ) {
      for ( uint y = 0 ; y < sBitmapHeader.nHeight ; ++y )
      {
	for ( uint x = 0 ; x < sBitmapHeader.nWidth / 2 ; ++x )
	{
	  int nPix = *pSrc++;
	  *pRaster++ = pasPallette[ nPix >> 4 ].red;
	  *pRaster++ = pasPallette[ nPix >> 4 ].green;
	  *pRaster++ = pasPallette[ nPix >> 4 ].blue;
	  *pRaster++ = 0;

	  *pRaster++ = pasPallette[ nPix & 0x0f ].red;
	  *pRaster++ = pasPallette[ nPix & 0x0f ].green;
	  *pRaster++ = pasPallette[ nPix & 0x0f ].blue;
	  *pRaster++ = 0;
	}
	if ( sBitmapHeader.nWidth & 0x01 ) {
	  pSrc++;
	}
	pSrc -= nLineSize * 2;
      }
    }
    delete[] pBuffer;
    delete[] pasPallette;
  }
  if ( pcBitmap != NULL ) {
    dbprintf( "Create view\n" );
    View* pcView = new View( pcBitmap->GetBounds(), "" );
    dbprintf( "Add view\n" );
    pcBitmap->AddChild( pcView );
    dbprintf( "Move pen\n" );
    pcView->MovePenTo( 10, 20 );
    pcView->SetFgColor( 255, 0, 120, 0 );
    dbprintf( "draw string\n" );
    pcView->DrawString( "Hello world" );
    dbprintf( "Flush\n" );
    pcView->Flush();
    dbprintf( "Done\n" );
  }
  return( pcBitmap );
}




Bitmap* LoadIcon( const char* pzPath )
{
  FILE* hFile = fopen( pzPath, "r" );

  if ( hFile == NULL ) {
    printf( "Failed to open %s\n", pzPath );
    return( NULL );
  }
  int nSize = 32 * 32;
  uint8* pBuffer = new uint8[nSize];
  uint8* pSrc = pBuffer;
  fread( pBuffer, 1, nSize, hFile );

  Bitmap* pcBitmap = new Bitmap( 32, 32, CS_RGB32 );
  uint8* pRaster = pcBitmap->LockRaster();
  
  for ( uint y = 0 ; y < 32 ; ++y )
  {
    for ( uint x = 0 ; x < 32 ; ++x )
    {
      int nPix = *pSrc++;
	  
      *pRaster++ = asDefaultPallette[ nPix ].nRed;
      *pRaster++ = asDefaultPallette[ nPix ].nGreen;
      *pRaster++ = asDefaultPallette[ nPix ].nBlue;
      *pRaster++ = 0;
    }
  }
  delete[] pBuffer;

  return( pcBitmap );
}

class BitmapView : public View
{
public:
  BitmapView( Bitmap* pcBitmap );
  virtual void	Paint( const Rect& cUpdateRect );
private:
  Bitmap* m_pcBitmap;
};

static Bitmap* load_bitmap( const char* pzPath )
{
    Translator* pcTrans = NULL;

    TranslatorFactory* pcFactory = new TranslatorFactory;
    pcFactory->LoadAll();
    
    Bitmap* pcBitmap = NULL;
    
    try {
	File cFile( pzPath );
	uint8  anBuffer[8192];
	uint   nFrameSize = 0;
	int    x;
	int    y;
	
	BitmapFrameHeader sFrameHeader;
	for (;;) {
	    int nBytesRead = cFile.Read( anBuffer, sizeof(anBuffer) );

	    if (nBytesRead == 0 ) {
		break;
	    }

	    if ( pcTrans == NULL ) {
		int nError = pcFactory->FindTranslator( "", TRANSLATOR_TYPE_IMAGE, anBuffer, nBytesRead, &pcTrans );
		if ( nError < 0 ) {
		    return( NULL );
		}
	    }
	    
	    pcTrans->AddData( anBuffer, nBytesRead, nBytesRead != sizeof(anBuffer) );

	    while( true ) {
		if ( pcBitmap == NULL ) {
		    BitmapHeader sBmHeader;
		    if ( pcTrans->Read( &sBmHeader, sizeof(sBmHeader) ) != sizeof( sBmHeader ) ) {
			break;
		    }
		    pcBitmap = new Bitmap( sBmHeader.bh_bounds.Width() + 1, sBmHeader.bh_bounds.Height() + 1, CS_RGB32 );
		}
		if ( nFrameSize == 0 ) {
		    if ( pcTrans->Read( &sFrameHeader, sizeof(sFrameHeader) ) != sizeof( sFrameHeader ) ) {
			break;
		    }
		    x = sFrameHeader.bf_frame.left * 4;
		    y = sFrameHeader.bf_frame.top;
		    nFrameSize = sFrameHeader.bf_data_size;
		}
		uint8 pFrameBuffer[8192];
		nBytesRead = pcTrans->Read( pFrameBuffer, min( nFrameSize, sizeof(pFrameBuffer) ) );
		if ( nBytesRead <= 0 ) {
		    break;
		}
		nFrameSize -= nBytesRead;
		uint8* pDstRaster = pcBitmap->LockRaster();
		int nSrcOffset = 0;
		for ( ; y <= sFrameHeader.bf_frame.bottom && nBytesRead > 0 ; ) {
		    int nLen = min( nBytesRead, sFrameHeader.bf_bytes_per_row - x );
		    memcpy( pDstRaster + y * pcBitmap->GetBytesPerRow() + x, pFrameBuffer + nSrcOffset, nLen );
		    if ( x + nLen == sFrameHeader.bf_bytes_per_row ) {
			x = 0;
			y++;
		    } else {
			x += nLen;
		    }
		    nBytesRead -= nLen;
		    nSrcOffset += nLen;
		}
	    }
	}
	return( pcBitmap );
    }
    catch( ... ) {
	return( NULL );
    }
}


BitmapView::BitmapView( Bitmap* pcBitmap ) : View( pcBitmap->GetBounds(), "bitmap_view" )
{
  m_pcBitmap = pcBitmap;
}

void BitmapView::Paint( const Rect& cUpdateRect )
{
    Rect cRect = m_pcBitmap->GetBounds();
    DrawBitmap( m_pcBitmap, cRect, cRect );
}

bool test_ext( const char* pzName, const char* pzExt )
{
    if ( strlen( pzName ) < strlen( pzExt ) ) {
	return( false );
    }
    return( strcasecmp( pzName + strlen( pzName ) - strlen( pzExt ), pzExt ) == 0 );
}

int main( int argc, char** argv )
{
    Application* pcApp = new Application( "application/x-vnd.KHS-bmview" );
    Bitmap* pcBitmap;

    pcBitmap = load_bitmap( argv[1] );

    if ( pcBitmap == NULL ) {
	if ( strstr( argv[1], ".bmp" ) != NULL ) {
	    pcBitmap = LoadBmp( argv[1] );
	} else {
	    pcBitmap = LoadIcon( argv[1] );
	}
    }
    if ( pcBitmap == NULL ) {
	fprintf( stderr, "Error: failed to load imnage\n" );
	return( 1 );
    }
    Window* pcWnd = new MyWindow( pcBitmap->GetBounds() + Point( 20, 20 ), "_jpeg_view", "Bitmap Viewer" );

    View* pcView = new BitmapView( pcBitmap );
    pcWnd->AddChild( pcView );
    pcWnd->Show();
    pcWnd->MakeFocus();
  
    pcApp->Run();
	
    return 0;
}
